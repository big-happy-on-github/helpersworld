<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q-Learning NFL Predictor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }

        h1 {
            color: #333;
        }

        input, button {
            padding: 10px;
            margin: 5px;
            font-size: 1em;
        }

        #output {
            margin-top: 20px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

    <h1>NFL Game Predictor</h1>
    <p>Enter two teams to predict the outcome:</p>
    <label for="team1">Team 1:</label>
    <input type="text" id="team1" placeholder="Team 1">
    <br>
    <label for="team2">Team 2:</label>
    <input type="text" id="team2" placeholder="Team 2">
    <br>
    <button onclick="predictOutcome()">Predict</button>

    <div id="output"></div>

    <script>
        let q_table = {};
        let state_space = {};
        let results = {};

        // Q-Learning parameters
        let learning_rate = 0.2;
        let discount_factor = 0.95;
        let exploration_rate = 1.0;
        let exploration_decay = 0.995;
        let min_exploration_rate = 0.01;

        // Placeholder for getting game data
        function getGameData(year) {
            // This part should make API calls. For now, we'll simulate with static data.
            console.log("Fetching data for year: " + year);
            let example_game = {
                state: ["team1", "team2"],
                home_score: 30,
                away_score: 27
            };
            let state = example_game.state.sort();
            state_space[state] = {
                "home_score": example_game.home_score,
                "away_score": example_game.away_score,
                "home_advantage": 1
            };
            if (state not in q_table) {
                q_table[state] = [Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1];
            }
        }

        // Function to choose action
        function chooseAction(state) {
            if (Math.random() < exploration_rate) {
                return Math.floor(Math.random() * 2); // Random action (exploration)
            } else {
                return q_table[state].indexOf(Math.max(...q_table[state])); // Choose based on Q-values (exploitation)
            }
        }

        // Function to update Q-table
        function updateQTable(state, action, reward, next_state) {
            let best_next_action = q_table[next_state].indexOf(Math.max(...q_table[next_state]));
            q_table[state][action] = q_table[state][action] + learning_rate * (
                reward + discount_factor * q_table[next_state][best_next_action] - q_table[state][action]
            );
        }

        // Function to predict outcome
        function predictOutcome() {
            let team1 = document.getElementById('team1').value.toLowerCase().trim();
            let team2 = document.getElementById('team2').value.toLowerCase().trim();
            
            if (!team1 || !team2) {
                document.getElementById('output').innerHTML = "Please enter both team names.";
                return;
            }

            let state = [team1, team2].sort();
            
            if (!q_table[state]) {
                q_table[state] = [Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1];
            }

            let action = chooseAction(state);
            let prediction = action === 0 ? team1 : team2;

            let resultText = `Prediction: ${prediction}`;
            document.getElementById('output').innerHTML = resultText;

            // Simulating user feedback and updating the Q-table
            let userFeedback = prompt("Was the prediction correct? (y/n)");
            let reward = userFeedback === "y" ? 2 : -5;
            updateQTable(state, action, reward, state);

            exploration_rate = Math.max(min_exploration_rate, exploration_rate * exploration_decay);
            console.log(`Exploration rate: ${exploration_rate}`);
        }

        // Simulate fetching game data for multiple years
        for (let year = 2015; year <= 2025; year++) {
            getGameData(year);
        }

    </script>
</body>
</html>
